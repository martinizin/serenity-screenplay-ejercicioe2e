HALLAZGOS Y CONCLUSIONES DEL EJERCICIO

Uno de los hallazgos técnicos más curiosos fue el conflicto entre la versión solicitada de Serenity (3.x) y mi navegador Chrome actual (v143). Para solucionarlo, configuré un entorno híbrido en Gradle: utilicé el plugin de Serenity 4.x para gestionar la descarga automática del driver W3C moderno, pero mantuve las librerías 'Core' mostradas en el workshop, en la versión 3.6.23 para respetar la arquitectura de referencia.

Otro reto interesante fue una alerta nativa de seguridad de Google ("Password Leak Detection") que bloqueaba la automatización tras el login. Logré evadirla inyectando argumentos específicos en el archivo `serenity.conf`, tales como `--disable-features=PasswordLeakDetection` y `--disable-save-password-bubble`.

Considero que también implemente una mejora en la prueba reemplazando XPaths absolutos por IDs dinámicos como se sugiere en el workshp en la capa de UserInterface y externalicé los datos a un JSON, logrando una ejecución robusta y mantenible.

Finalmente, a diferencia de otros reportes estándar que solo indican "Pass/Fail", noté que al usar el patrón Screenplay correctamente  (con Stepdefinitions y Tasks nombrados), el reporte HTML final actúa como una "evidencia auditora" detallada. Esto elimina la brecha entre el código y el cliente, ya que cada captura de pantalla corresponde a una intención del usuario y no solo a una línea de código.